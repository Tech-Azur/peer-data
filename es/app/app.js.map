{"version":3,"file":"app.js","sourceRoot":"","sources":["../../src/app/app.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,eAAe,EAAE,MAAM,yBAAyB,CAAC;AAE1D,OAAO,EAAE,SAAS,IAAI,kBAAkB,EAAE,MAAM,yBAAyB,CAAC;AAC1E,OAAO,EAAE,UAAU,EAAE,MAAM,yBAAyB,CAAC;AACrD,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;AAGlC,MAAM;IAGJ,YAAY,UAA4B,EAAE,EAAE,kBAAsC,IAAI;QACpF,MAAM,UAAU,GAAG,IAAI,UAAU,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC;QAC5D,IAAI,CAAC,MAAM,GAAG,IAAI,MAAM,CAAC,UAAU,CAAC,CAAC;IACvC,CAAC;IAED,EAAE,CAAC,KAAgB,EAAE,QAAsB;QACzC,eAAe,CAAC,QAAQ,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IAC5C,CAAC;IAED,IAAI,CAAC,IAAS,EAAE,EAAW;QACzB,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YACP,MAAM,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;YACpD,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;gBACZ,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACrB,CAAC;QACH,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM;iBACH,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC;iBACxC,OAAO,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,KAAK,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QACjD,CAAC;IACH,CAAC;IAED,OAAO,CAAC,MAAe;QACrB,IAAI,KAAK,GAAU;YACjB,IAAI,EAAE,kBAAkB,CAAC,OAAO;YAChC,MAAM,EAAE,IAAI;YACZ,MAAM,EAAE,IAAI;YACZ,IAAI,EAAE,EAAE,EAAE,EAAE,MAAM,EAAE;YACpB,IAAI,EAAE,IAAI;SACX,CAAC;QACF,eAAe,CAAC,QAAQ,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;IAC1C,CAAC;IAED,UAAU,CAAC,MAAe;QACxB,MAAM;aACH,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC;aACxC,OAAO,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,KAAK,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;QAE5C,MAAM;aACH,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC;aACrC,OAAO,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,KAAK,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;QAE5C,MAAM,KAAK,GAAU;YACnB,IAAI,EAAE,kBAAkB,CAAC,UAAU;YACnC,MAAM,EAAE,IAAI;YACZ,MAAM,EAAE,IAAI;YACZ,IAAI,EAAE,EAAE,EAAE,EAAE,MAAM,EAAE;YACpB,IAAI,EAAE,IAAI;SACX,CAAC;QACF,eAAe,CAAC,QAAQ,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;IAC1C,CAAC;CACF","sourcesContent":["import { EventType } from './channel/event-type';\nimport { EventDispatcher } from './dispatcher/dispatcher';\nimport { Event } from './connection/event';\nimport { EventType as SignalingEventType } from './connection/event-type';\nimport { Connection } from './connection/connection';\nimport { Bridge } from './bridge';\nimport { EventHandler } from './dispatcher/handler'\n\nexport class App {\n  private bridge: Bridge;\n\n  constructor(servers: RTCConfiguration = {}, dataConstraints: RTCDataChannelInit = null) {\n    const connection = new Connection(servers, dataConstraints);\n    this.bridge = new Bridge(connection);\n  }\n\n  on(event: EventType, callback: EventHandler) {\n    EventDispatcher.register(event, callback);\n  }\n\n  send(data: any, id?: string) {\n    if (id) {\n      const channel = this.bridge.connection.channels[id];\n      if (channel) {\n        channel.send(data);\n      }\n    } else {\n      Object\n        .entries(this.bridge.connection.channels)\n        .forEach(([key, value]) => value.send(data));\n    }\n  }\n\n  connect(roomId?: string) {\n    let event: Event = {\n      type: SignalingEventType.CONNECT,\n      caller: null,\n      callee: null,\n      room: { id: roomId },\n      data: null\n    };\n    EventDispatcher.dispatch('send', event);\n  }\n\n  disconnect(roomId?: string) {\n    Object\n      .entries(this.bridge.connection.channels)\n      .forEach(([key, value]) => value.close());\n\n    Object\n      .entries(this.bridge.connection.peers)\n      .forEach(([key, value]) => value.close());\n\n    const event: Event = {\n      type: SignalingEventType.DISCONNECT,\n      caller: null,\n      callee: null,\n      room: { id: roomId },\n      data: null\n    };\n    EventDispatcher.dispatch('send', event);\n  }\n}\n"]}